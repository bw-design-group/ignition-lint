# PyPI Publishing Setup Plan for ign-lint

## Overview
Document and implement the complete process for publishing ign-lint as a pip-installable package on PyPI. The project is already well-configured for distribution but lacks automated publishing infrastructure and has version synchronization issues.

## Current State Assessment

### What's Already Working âœ…
- **Package Structure**: Proper src-layout following PEP 517/518 standards
- **Build Configuration**: Poetry-based build system properly configured
- **CLI Entry Point**: `ign-lint` command defined in pyproject.toml
- **Documentation**: Comprehensive README with installation instructions (already mentions PyPI)
- **CI/CD Testing**: Robust test suite with GitHub Actions (linting, unit, integration)
- **Build Artifacts**: CI already builds wheel and tarball in `.github/workflows/ci.yml`
- **Version Control**: Clear git tag-based versioning (currently at v0.2.10)
- **Changelog**: Well-maintained CHANGELOG.md following Keep a Changelog format
- **License**: MIT license properly declared

### Issues to Address âš ï¸
1. **Version Mismatch**: pyproject.toml shows `0.1.0` but git tags are at `v0.2.10`
2. **No PyPI Publishing**: No automated workflow to publish to PyPI
3. **Missing PyPI Credentials**: No PYPI_API_TOKEN configured in GitHub secrets
4. **Limited Metadata**: Missing PyPI classifiers and keywords for discoverability
5. **Dependency Categorization**: `pre-commit` listed as runtime dependency (should be dev-only)
6. **Python Version Constraint**: `ignition-api-stubs` blocks Python 3.13 support (but isn't actually used at runtime)
7. **No Release Documentation**: No RELEASING.md or documented release process

## Implementation Steps

### Phase 1: Metadata and Configuration Updates

#### Step 1.1: Update pyproject.toml Metadata
**File**: `pyproject.toml`

**Changes needed**:
```toml
[tool.poetry]
name = "ign-lint"
version = "0.3.0"  # Update from 0.1.0 - marks PyPI availability as new feature

# Add these new fields:
keywords = [
    "ignition",
    "perspective",
    "linting",
    "json",
    "scada",
    "quality-assurance",
    "static-analysis"
]

classifiers = [
    "Development Status :: 4 - Beta",
    "Environment :: Console",
    "Intended Audience :: Developers",
    "Intended Audience :: Manufacturing",
    "License :: OSI Approved :: MIT License",
    "Operating System :: OS Independent",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Python :: 3.13",
    "Topic :: Software Development :: Quality Assurance",
    "Topic :: Software Development :: Testing",
    "Topic :: Text Processing :: Markup :: JSON",
    "Typing :: Typed"
]

# Update Python version to support 3.13, remove unused dependency
[tool.poetry.dependencies]
python = ">=3.10,<3.14"  # Updated to support Python 3.13
pylint = "*"
# ignition-api-stubs = "^8.1.48.post1"  # REMOVE - not used at runtime, blocks Python 3.13
# pre-commit = "^4.2.0"  # Remove from runtime dependencies

[tool.poetry.group.dev.dependencies]
yapf = "*"
pre-commit = "^4.2.0"  # Moved from runtime dependencies
ignition-api-stubs = "^8.3.3"  # Moved here if needed for development/testing
```

**Rationale**:
- Version sync prevents confusion between package version and git tags
- Keywords improve PyPI search discoverability
- Classifiers help users filter and find the package
- pre-commit is only needed for development, not when using the tool
- ignition-api-stubs is not imported anywhere in the codebase (verified via grep)
- Removing ignition-api-stubs enables Python 3.13 support (stubs only support <3.13)
- Python 3.13 support future-proofs the package

#### Step 1.2: Review Package Includes
**File**: `pyproject.toml`

**Verify includes**:
```toml
packages = [
    { include = "ignition_lint", from = "src" }
]
include = [
    ".config/**/*"  # Bundled for default pylintrc access
]
```

**Validation**:
- `.config/.pylintrc` is needed at runtime (included âœ…)
- No test files or debug scripts should be included
- Documentation (README.md, CHANGELOG.md) auto-included by Poetry

### Phase 2: PyPI Account and Credentials Setup

#### Step 2.1: Create PyPI Account (if not exists)
**Action**: Manual account creation

1. Go to https://pypi.org/account/register/
2. Create account with maintainer email
3. Enable 2FA for security
4. Verify email address

#### Step 2.2: Create Test PyPI Account (Recommended)
**Action**: Manual account creation

1. Go to https://test.pypi.org/account/register/
2. Create separate test account
3. Use for testing release process before production

**Rationale**: Test PyPI allows validating the entire publish workflow without affecting the production package registry.

#### Step 2.3: Generate PyPI API Tokens
**Action**: Generate tokens for CI/CD

**Production PyPI**:
1. Login to https://pypi.org
2. Go to Account Settings â†’ API tokens
3. Create new token:
   - Token name: `ign-lint-github-actions`
   - Scope: `Project: ign-lint` (after first manual upload)
4. Save token securely (shown only once)

**Test PyPI** (for testing):
1. Login to https://test.pypi.org
2. Same process as above
3. Token name: `ign-lint-github-actions-test`

**Important**: For first release, create token with "Entire account" scope, then restrict to project after first publish.

#### Step 2.4: Add Secrets to GitHub Repository
**Action**: Configure repository secrets

1. Go to repository Settings â†’ Secrets and variables â†’ Actions
2. Add repository secrets:
   - `PYPI_API_TOKEN`: Production PyPI token
   - `TEST_PYPI_API_TOKEN`: Test PyPI token (optional but recommended)

**Security Note**: Never commit tokens to repository or expose in logs.

### Phase 3: Automated Publishing Workflow

#### Step 3.0: Consolidate and Optimize CI Workflows

**Actions:**
1. Rename `.github/workflows/ci.yml` â†’ `.github/workflows/ci-pipeline.yml`
2. Update `ci-pipeline.yml` (optimize triggers, add Python 3.13)
3. Delete `.github/workflows/unittest.yml` (redundant)
4. Delete `.github/workflows/integration-test.yml` (redundant)

**Why delete the separate workflows?**
- ci-pipeline.yml already runs both unit and integration tests
- Separate workflows run on EVERY push (wasteful)
- unittest.yml has broken trigger (`types: [closed]` runs AFTER merge)
- Use older Python versions (3.11, 3.12)
- Result: 3x redundant test runs

**Why rename ci.yml to ci-pipeline.yml?**
- More descriptive than generic "ci.yml"
- Clearly indicates it's the main CI/CD pipeline
- Distinguishes it from other CI-related workflows (prepare-release, publish)

**File**: `.github/workflows/ci-pipeline.yml` (RENAME + UPDATE from ci.yml)

**Optimization strategy:**
- PRs to dev: Test on Python 3.13 only (fast feedback, latest version)
- PRs to main: Test on all versions 3.10-3.13 (thorough validation)
- Skip push events (tests already passed in PR)

**Changes needed**:
```yaml
name: CI Pipeline

on:
  pull_request:
    branches: [ main, dev ]  # Only run on PRs
  workflow_dispatch:         # Allow manual trigger

permissions:
  contents: read

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        # Smart matrix: all versions for main PRs, latest version for dev PRs
        python-version: >-
          ${{
            github.base_ref == 'main' &&
            fromJSON('["3.10", "3.11", "3.12", "3.13"]') ||
            fromJSON('["3.13"]')
          }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install Poetry
        run: |
          curl -sSL https://install.python-poetry.org | python3 -
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Configure Poetry
        run: |
          poetry config virtualenvs.create true
          poetry config virtualenvs.in-project true

      - name: Cache Poetry dependencies
        uses: actions/cache@v4
        with:
          path: .venv
          key: poetry-${{ runner.os }}-${{ matrix.python-version }}-${{ hashFiles('**/poetry.lock') }}
          restore-keys: |
            poetry-${{ runner.os }}-${{ matrix.python-version }}-

      - name: Install dependencies
        run: poetry install

      - name: Run linting with pylint
        run: poetry run pylint --rcfile=.config/.pylintrc ignition_lint/

      - name: Run unit tests
        run: |
          cd tests
          poetry run python test_runner.py --run-unit

      - name: Run integration tests
        run: |
          cd tests
          poetry run python test_runner.py --run-integration

      - name: Test CLI functionality
        run: |
          poetry run python -m ignition_lint --help
          poetry run python -m ignition_lint --config .github/workflows/.ignition-lint-ci.json --files tests/cases/PascalCase/view.json --ignore-warnings

  build:
    runs-on: ubuntu-latest
    needs: test
    # Only build on PRs to main (release prep)
    if: github.base_ref == 'main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.13"  # Use latest supported version

      - name: Install Poetry
        run: |
          curl -sSL https://install.python-poetry.org | python3 -
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Build package
        run: poetry build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist
          path: dist/
```

**What this achieves:**
- âœ… PRs to dev: Fast feedback (~2 min, Python 3.13 only)
- âœ… PRs to main: Thorough validation (~6 min, all versions 3.10-3.13)
- âœ… Build artifacts only for release PRs
- âœ… No redundant runs after merge
- âœ… Python 3.13 compatibility validated on every PR

#### Step 3.1: Create PyPI Publishing Workflow
**File**: `.github/workflows/publish.yml` (new file)

**Workflow configuration**:
```yaml
name: Publish to PyPI

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      test_pypi:
        description: 'Publish to Test PyPI instead of production'
        required: false
        type: boolean
        default: false

permissions:
  contents: read

jobs:
  publish:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.13"

      - name: Install Poetry
        run: |
          curl -sSL https://install.python-poetry.org | python3 -
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Build package
        run: poetry build

      - name: Publish to Test PyPI
        if: github.event.inputs.test_pypi == 'true'
        env:
          POETRY_PYPI_TOKEN_TESTPYPI: ${{ secrets.TEST_PYPI_API_TOKEN }}
        run: |
          poetry config repositories.testpypi https://test.pypi.org/legacy/
          poetry publish -r testpypi

      - name: Publish to PyPI
        if: github.event_name == 'release' && github.event.inputs.test_pypi != 'true'
        env:
          POETRY_PYPI_TOKEN_PYPI: ${{ secrets.PYPI_API_TOKEN }}
        run: poetry publish
```

**Workflow triggers**:
- **Automatic**: On GitHub release publication
- **Manual**: Via workflow_dispatch with Test PyPI option

**Rationale**:
- GitHub releases provide a clear manual gate before publishing
- Manual dispatch allows testing without creating releases
- Test PyPI option validates workflow before production

#### Step 3.2: Optional - Version Validation Workflow
**File**: `.github/workflows/validate-version.yml` (new file)

**Purpose**: Prevent releases with mismatched versions

```yaml
name: Validate Version

on:
  pull_request:
    branches: [main]
    paths:
      - 'pyproject.toml'

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Extract version from pyproject.toml
        id: version
        run: |
          VERSION=$(grep '^version = ' pyproject.toml | cut -d'"' -f2)
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Check if git tag exists
        run: |
          if git rev-parse "v${{ steps.version.outputs.version }}" >/dev/null 2>&1; then
            echo "âœ… Git tag v${{ steps.version.outputs.version }} exists"
          else
            echo "âš ï¸  Warning: No git tag for v${{ steps.version.outputs.version }}"
            echo "Create tag before release: git tag v${{ steps.version.outputs.version }}"
          fi
```

### Phase 4: Release Process Documentation

#### Step 4.1: Create RELEASING.md
**File**: `RELEASING.md` (new file at repository root)

**Content outline**:
```markdown
# Release Process for ign-lint

## Overview
This document describes the process for releasing new versions of ign-lint to PyPI.

## Prerequisites
- Maintainer access to GitHub repository
- PyPI credentials configured in GitHub Actions secrets
- All tests passing on main branch
- CHANGELOG.md updated with release notes

## Semantic Versioning
This project follows [Semantic Versioning](https://semver.org/):
- **MAJOR** (X.0.0): Breaking changes
- **MINOR** (0.X.0): New features, backwards-compatible
- **PATCH** (0.0.X): Bug fixes, backwards-compatible

## Release Steps (Fully Automated)

**Workflow Context:**
- Feature development: `feature/*` â†’ PR â†’ `dev` (protected)
- Release prep: RC tag on dev â†’ automated PR creation
- Production release: Tag main â†’ PyPI publish

### Step 1: Tag Dev with Release Candidate

Once all features are merged to dev and you're ready to release:

```bash
git checkout dev
git pull origin dev

# Tag with RC version (triggers automation)
git tag v0.3.1-RC1 -m "Release candidate for v0.3.1"
git push origin v0.3.1-RC1
```

**What happens automatically:**
1. ðŸ¤– GitHub Action triggers on RC tag push
2. ðŸ¤– Extracts version (v0.3.1-RC1 â†’ 0.3.1)
3. ðŸ¤– Finds commits since last release tag
4. ðŸ¤– Generates changelog from commit messages
5. ðŸ¤– Updates `pyproject.toml` version
6. ðŸ¤– Updates `CHANGELOG.md` with generated content
7. ðŸ¤– Commits changes to dev
8. ðŸ¤– Creates PR: dev â†’ main with full changelog

### Step 2: Review and Approve PR

1. Go to Pull Requests â†’ "Release vX.Y.Z"
2. Review the auto-generated changelog
3. **Edit CHANGELOG.md if needed** (fix categorization, add details)
4. Ensure CI checks pass
5. Approve and merge PR to main

### Step 3: Tag Production Release on Main
After PR is merged to main:

```bash
git checkout main
git pull origin main

# Create production release tag
git tag v0.3.1 -m "Release v0.3.1"
git push origin v0.3.1
```

**This triggers the automated PyPI publish workflow** (from Phase 3).

### Step 4: Create GitHub Release (Optional but Recommended)
1. Go to https://github.com/design-group/ignition-lint/releases/new
2. Select tag: v0.3.1
3. Release title: "v0.3.1"
4. Click "Generate release notes" or copy from CHANGELOG.md
5. Click "Publish release"

**Note:** GitHub Release is optional. PyPI publish triggers on tag push (Step 3).

### Step 5: Verify PyPI Publication
The publish workflow automatically:
1. Triggers on production tag push (v0.3.1)
2. Builds package with Poetry
3. Publishes to PyPI using configured token

**Monitor progress:**
- Actions: https://github.com/design-group/ignition-lint/actions
- PyPI: https://pypi.org/project/ign-lint/

### Step 6: Verify Installation
```bash
# Wait 1-2 minutes for PyPI propagation
pip install ign-lint==X.Y.Z

# Verify version
ign-lint --version
```

## Testing Release Process

### Test PyPI Workflow
Before production release, test with Test PyPI:

```bash
# 1. Manually trigger workflow
# Go to Actions â†’ Publish to PyPI â†’ Run workflow
# Check "test_pypi" option

# 2. After workflow completes, test installation
pip install --index-url https://test.pypi.org/simple/ ign-lint==0.2.11
```

## Rollback Procedure

If issues are discovered after release:

1. **Cannot delete from PyPI** - versions are permanent
2. **Yank the release**: Mark as unstable on PyPI (prevents new installs)
3. **Release patch version**: Fix issues and release 0.2.12
4. **Update documentation**: Note issues in CHANGELOG.md

## Fully Automated Release Preparation (Recommended)

This is the recommended approach based on user workflow preferences.

### Workflow Overview

```
1. Tag dev with RC:  git tag v0.3.0-RC1 && git push origin v0.3.0-RC1
2. ðŸ¤– Action runs:   Bumps version, generates changelog, creates PR
3. ðŸ‘¤ Review PR:     Check changes, approve
4. ðŸ‘¤ Merge PR:      dev â†’ main
5. ðŸ‘¤ Tag main:      git tag v0.3.0 && git push origin v0.3.0
6. ðŸ¤– PyPI publish:  Triggered by production tag
```

### Implementation

**File:** `.github/workflows/prepare-release.yml` (NEW)

```yaml
name: Prepare Release from RC Tag

on:
  push:
    tags:
      - 'v*-RC*'  # Triggers on tags like v0.3.0-RC1, v1.2.3-RC2, etc.

permissions:
  contents: write
  pull-requests: write

jobs:
  prepare-release:
    runs-on: ubuntu-latest

    steps:
      - name: Extract version from tag
        id: version
        run: |
          # Extract version from tag (v0.3.0-RC1 â†’ 0.3.0)
          TAG="${GITHUB_REF#refs/tags/}"
          VERSION="${TAG%%-RC*}"
          VERSION="${VERSION#v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "rc_tag=$TAG" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Preparing release for version: $VERSION"

      - name: Checkout dev branch
        uses: actions/checkout@v4
        with:
          ref: dev
          fetch-depth: 0  # Full history for changelog generation
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.13"

      - name: Install Poetry
        run: |
          curl -sSL https://install.python-poetry.org | python3 -
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Get last release tag
        id: last_release
        run: |
          # Find the most recent non-RC tag
          LAST_TAG=$(git tag --list 'v*' --sort=-version:refname | grep -v 'RC' | head -n1)
          LAST_VERSION="${LAST_TAG#v}"
          echo "last_tag=$LAST_TAG" >> $GITHUB_OUTPUT
          echo "last_version=$LAST_VERSION" >> $GITHUB_OUTPUT
          echo "ðŸ“Š Last release: $LAST_TAG"

      - name: Update pyproject.toml version
        run: |
          poetry version "${{ steps.version.outputs.version }}"
          echo "âœ… Updated pyproject.toml to version ${{ steps.version.outputs.version }}"

      - name: Update CHANGELOG.md (idempotent)
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          LAST_VERSION="${{ steps.last_release.outputs.last_version }}"
          DATE=$(date +%Y-%m-%d)

          echo "ðŸ”„ Updating CHANGELOG.md for version ${VERSION}..."

          # Check if this version already exists (e.g., from previous RC run)
          if grep -q "## \[${VERSION}\]" CHANGELOG.md; then
            echo "âš ï¸  Version ${VERSION} already exists in CHANGELOG"
            echo "   Updating date and ensuring [Unreleased] section exists..."

            # Update the date on existing version
            sed -i "s/## \[${VERSION}\] - .*/## [${VERSION}] - ${DATE}/" CHANGELOG.md

            # Ensure [Unreleased] section exists at top
            if ! grep -q "## \[Unreleased\]" CHANGELOG.md; then
              sed -i "/# Changelog/a\\
\\
## [Unreleased]" CHANGELOG.md
              echo "   Added missing [Unreleased] section"
            fi
          else
            echo "âœ¨ First run for ${VERSION}, creating new section..."

            # Ensure [Unreleased] section exists (defensive)
            if ! grep -q "## \[Unreleased\]" CHANGELOG.md; then
              sed -i "/# Changelog/a\\
\\
## [Unreleased]" CHANGELOG.md
            fi

            # Replace [Unreleased] with versioned heading
            sed -i "s/## \[Unreleased\]/## [${VERSION}] - ${DATE}/" CHANGELOG.md

            # Add new [Unreleased] section at top
            sed -i "/# Changelog/a\\
\\
## [Unreleased]" CHANGELOG.md
          fi

          # Update comparison links (idempotent - remove old, add new)
          # Remove existing version link if present
          sed -i "/^\[${VERSION}\]:/d" CHANGELOG.md

          # Add version comparison link
          echo "[${VERSION}]: https://github.com/design-group/ignition-lint/compare/v${LAST_VERSION}...v${VERSION}" >> CHANGELOG.md

          # Update Unreleased link to compare from new version
          sed -i "s|\[Unreleased\]:.*|[Unreleased]: https://github.com/design-group/ignition-lint/compare/v${VERSION}...HEAD|" CHANGELOG.md

          echo "âœ… CHANGELOG.md updated successfully"
          echo "   Version: ${VERSION}"
          echo "   Date: ${DATE}"

      - name: Commit changes to dev
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add pyproject.toml CHANGELOG.md
          git commit -m "chore: Prepare release v${{ steps.version.outputs.version }}

          Auto-generated from RC tag ${{ steps.version.outputs.rc_tag }}

          - Updated version in pyproject.toml
          - Generated changelog from commits since ${{ steps.last_release.outputs.last_tag }}"

          git push origin dev

      - name: Create or Update Pull Request
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          LAST_TAG="${{ steps.last_release.outputs.last_tag }}"

          # Extract the changelog section for this version from CHANGELOG.md
          CHANGELOG_SECTION=$(sed -n "/## \[${VERSION}\]/,/## \[/p" CHANGELOG.md | sed '$d')

          # Get commit list for reference
          COMMIT_LIST=$(git log ${LAST_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges | head -30)

          # Create PR body
          cat > /tmp/pr_body.md << EOF
          ## Release v${VERSION}

          This PR was automatically generated from RC tag \`${{ steps.version.outputs.rc_tag }}\`.

          ### Changes in this release

          ${CHANGELOG_SECTION}

          ### Commits included (since ${LAST_TAG})

          ${COMMIT_LIST}

          ---

          **Next steps:**
          1. Review the changelog above
          2. Edit CHANGELOG.md if needed (add missing entries, improve wording)
          3. Approve and merge this PR
          4. Tag main with production release:
             \`\`\`bash
             git checkout main && git pull
             git tag v${VERSION}
             git push origin v${VERSION}
             \`\`\`
          5. Create GitHub Release from v${VERSION} tag (optional)
          6. PyPI publish will trigger automatically
          EOF

          # Check if PR already exists for this release
          EXISTING_PR=$(gh pr list --base main --head dev --state open --json number --jq '.[0].number')

          if [ -n "$EXISTING_PR" ]; then
            echo "âš ï¸  PR #${EXISTING_PR} already exists (dev â†’ main)"
            echo "   Updating PR description with latest changes..."

            gh pr edit "$EXISTING_PR" \
              --title "Release v${VERSION}" \
              --body-file /tmp/pr_body.md

            echo "âœ… Updated existing PR #${EXISTING_PR}"
          else
            echo "âœ¨ Creating new PR (dev â†’ main)..."

            gh pr create \
              --base main \
              --head dev \
              --title "Release v${VERSION}" \
              --body-file /tmp/pr_body.md \
              --label "release"

            echo "âœ… Created new PR"
          fi

      - name: Summary
        run: |
          echo "âœ… Release preparation complete!"
          echo ""
          echo "ðŸ“‹ Summary:"
          echo "  - Version: ${{ steps.version.outputs.version }}"
          echo "  - RC Tag: ${{ steps.version.outputs.rc_tag }}"
          echo "  - Updated: pyproject.toml, CHANGELOG.md"
          echo "  - Committed to: dev"
          echo "  - PR created: dev â†’ main"
          echo ""
          echo "ðŸ‘‰ Next: Review and approve the PR, then tag main for production release"
```

**Key Features:**

1. **Automatic Version Extraction**: `v0.3.0-RC1` â†’ `0.3.0`
2. **Changelog Transformation** (mechanical only):
   - Changes `## [Unreleased]` â†’ `## [0.3.0] - 2026-02-01`
   - Adds new `## [Unreleased]` section at top
   - Updates comparison links at bottom
   - **Does NOT modify your content** - you maintain full control
3. **Auto-generated PR**:
   - Shows your changelog content
   - Lists commits for reference
   - Clear next steps for maintainer
4. **Branch Protection Friendly**: Bot can commit to protected branches

**Your Changelog Workflow:**

You maintain the changelog manually as you work:

```markdown
# Changelog

## [Unreleased]

### Added
- Support for Python 3.13
- New BadComponentReferenceRule

### Fixed
- Remove unused ignition-api-stubs dependency
- Correct false positive in name pattern

### Changed
- Move pre-commit to dev dependencies
```

When you tag RC, the automation transforms it to:

```markdown
# Changelog

## [Unreleased]

## [0.3.0] - 2026-02-01

### Added
- Support for Python 3.13
- New BadComponentReferenceRule

### Fixed
- Remove unused ignition-api-stubs dependency
- Correct false positive in name pattern

### Changed
- Move pre-commit to dev dependencies

[Unreleased]: https://github.com/.../compare/v0.3.0...HEAD
[0.3.0]: https://github.com/.../compare/v0.2.10...v0.3.0
```

**Advantages:**
- âœ… You write the changelog as you work (or before RC tag)
- âœ… Automation just handles version numbers and dates
- âœ… Can still edit in PR if you forgot something
- âœ… Follows "Keep a Changelog" format perfectly
- âœ… No risk of auto-generated content being wrong

## Workflow Notes

**Why this workflow works well:**
- âœ… **Matches existing pattern** - Already using devâ†’main merges
- âœ… **Simple** - No release branches to manage
- âœ… **RC tags** - Optional testing checkpoint before production
- âœ… **Clean history** - Version bumps on dev, production tags on main
- âœ… **Flexible** - Can test RC before finalizing release

**Alternative: Skip RC tags**
If confident in CI testing, can skip RC tags and go straight from devâ†’main PRâ†’production tag.

## Troubleshooting

### Build Failures
- Check Poetry configuration: `poetry check`
- Validate dependencies: `poetry update`
- Test local build: `poetry build`

### Authentication Errors
- Verify PYPI_API_TOKEN is configured in GitHub secrets
- Check token hasn't expired
- Ensure token has correct scope (project-specific)

### Version Conflicts
- Ensure pyproject.toml version matches git tag
- Check PyPI doesn't already have this version
- Version numbers cannot be reused

## Emergency Contact
For urgent release issues, contact repository maintainers:
- Eric Knorr
- Alex Spyksma
```

#### Step 4.2: Update CLAUDE.md
**File**: `CLAUDE.md`

**Add release section**:
```markdown
## Release Process

### Publishing to PyPI

For detailed instructions on releasing new versions, see [RELEASING.md](RELEASING.md).

**Quick Reference:**
1. Update version in `pyproject.toml`
2. Update `CHANGELOG.md`
3. Create PR and merge to main
4. Create git tag: `git tag v0.X.Y`
5. Push tag: `git push origin v0.X.Y`
6. Create GitHub Release
7. Automated workflow publishes to PyPI

**Testing before production:**
Use workflow_dispatch with Test PyPI option to validate before real release.
```

### Phase 5: First Production Release

#### Step 5.1: Manual Test Release to Test PyPI
**Action**: Validate entire workflow before production

```bash
# 1. Update version in pyproject.toml to 0.3.0
# (This will be the first PyPI release)

# 2. Build locally to verify
poetry build

# 3. Inspect build artifacts
ls -lh dist/
# Should see:
# - ignition_lint-0.3.0-py3-none-any.whl
# - ignition_lint-0.3.0.tar.gz

# 4. Check contents of wheel
unzip -l dist/ignition_lint-0.3.0-py3-none-any.whl
# Verify includes:
# - ignition_lint/ source code
# - .config/.pylintrc
# - No test files or debug scripts

# 5. Manual publish to Test PyPI (first time)
poetry config repositories.testpypi https://test.pypi.org/legacy/
poetry publish -r testpypi
# Enter Test PyPI token when prompted

# 6. Test installation from Test PyPI
pip install --index-url https://test.pypi.org/simple/ \
    --extra-index-url https://pypi.org/simple/ \
    ign-lint==0.3.0

# 7. Verify functionality
ign-lint --help
ign-lint --config rule_config.json --files tests/cases/PascalCase/view.json
```

**Dependencies note**: `--extra-index-url` allows pip to install dependencies (like pylint) from production PyPI while getting ign-lint from Test PyPI.

#### Step 5.2: Production PyPI First Publish
**Action**: Initial manual publish or GitHub release

**Manual Production Publish** (recommended approach based on user preference)
```bash
# 1. Verify version is 0.3.0 in pyproject.toml
grep version pyproject.toml

# 2. Build fresh (remove any test builds first)
rm -rf dist/
poetry build

# 3. Publish to production PyPI
poetry publish
# Enter production PyPI token when prompted

# 4. Verify on PyPI
# Visit: https://pypi.org/project/ign-lint/
# Should show version 0.3.0

# 5. Test installation
pip install ign-lint==0.3.0
ign-lint --help

# 6. Create git tag to match published version
git tag -a v0.3.0 -m "Release v0.3.0 - First PyPI publication"
git push origin v0.3.0

# 7. Create GitHub Release for documentation
# - Go to https://github.com/design-group/ignition-lint/releases/new
# - Select tag: v0.3.0
# - Title: "v0.3.0 - First PyPI Release"
# - Description from CHANGELOG.md, note: "Now available on PyPI!"
```

**Note**: For subsequent releases, the automated GitHub Release workflow can be used. This manual approach for v0.3.0 ensures the initial publish is carefully controlled.

#### Step 5.3: Restrict PyPI Token Scope
**Action**: Security hardening after first publish

1. Go to https://pypi.org Account Settings â†’ API tokens
2. Delete the account-scoped token
3. Create new project-scoped token:
   - Token name: `ign-lint-github-actions`
   - Scope: `Project: ign-lint`
4. Update GitHub secret `PYPI_API_TOKEN` with new project-scoped token

**Rationale**: Project-scoped tokens limit blast radius if token is compromised.

### Phase 6: Verification and Documentation

#### Step 6.1: End-to-End Installation Test
**Action**: Verify full user experience

```bash
# Fresh environment test
python -m venv test-env
source test-env/bin/activate  # On Windows: test-env\Scripts\activate

# Install from PyPI
pip install ign-lint

# Verify CLI is available
ign-lint --version
ign-lint --help

# Test basic functionality
cd /path/to/ignition/project
ign-lint --files "views/**/view.json"

# Test pre-commit integration (from README)
# Create .pre-commit-config.yaml with ign-lint hook
pre-commit install
pre-commit run ign-lint --all-files

# Cleanup
deactivate
rm -rf test-env
```

#### Step 6.2: Update README Badge (Optional)
**File**: `README.md`

**Add PyPI badge**:
```markdown
# Ignition Lint Documentation

[![PyPI version](https://badge.fury.io/py/ign-lint.svg)](https://badge.fury.io/py/ign-lint)
[![Python Versions](https://img.shields.io/pypi/pyversions/ign-lint.svg)](https://pypi.org/project/ign-lint/)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

## Overview
...
```

#### Step 6.3: Validate Pre-commit Remote Repository Usage
**Action**: Test pre-commit hook works from PyPI package

Users can reference ign-lint in their `.pre-commit-config.yaml`:
```yaml
repos:
  - repo: https://github.com/design-group/ignition-lint
    rev: v0.2.10  # Use latest release tag
    hooks:
      - id: ign-lint
        args: ['--config=.ignition-lint.json', '--files']
        exclude: '^tests/.*'
```

**Verify**: Create test repo and confirm hook installs and runs correctly.

## Critical Files Summary

### Files to Modify
1. **pyproject.toml**
   - Update version to 0.2.10
   - Add keywords and classifiers
   - Move pre-commit to dev dependencies

2. **.github/workflows/publish.yml** (NEW)
   - Automated PyPI publishing workflow
   - Triggers on GitHub releases
   - Manual dispatch option for Test PyPI

3. **RELEASING.md** (NEW)
   - Complete release process documentation
   - Troubleshooting guide
   - Testing procedures

4. **CLAUDE.md**
   - Add release process section
   - Reference RELEASING.md

5. **README.md** (OPTIONAL)
   - Add PyPI badge
   - Already documents pip installation

### Repository Secrets Required
- `PYPI_API_TOKEN`: Production PyPI API token (required)
- `TEST_PYPI_API_TOKEN`: Test PyPI token (recommended for testing)

## Timeline Estimate

**Note**: Per guidelines, no time estimates are provided. Steps are broken down into atomic actions that can be completed independently.

### Sequential Dependencies
1. **Phase 1** must complete before testing builds
2. **Phase 2** must complete before automated publishing
3. **Phase 3** requires Phase 2 completion
4. **Phase 5** should follow Phases 1-3 for smooth first release
5. **Phase 6** validates Phase 5 completion

### Parallel Opportunities
- Documentation (Phase 4) can be written while setting up credentials (Phase 2)
- Test PyPI testing (Phase 5.1) can be iterative during workflow development (Phase 3)

## Success Criteria

### Immediate (After First Release)
- âœ… Package published on PyPI at https://pypi.org/project/ign-lint/
- âœ… Version on PyPI matches git tag and pyproject.toml
- âœ… `pip install ign-lint` installs successfully
- âœ… CLI command `ign-lint` is available after installation
- âœ… Pre-commit hook works when referenced from GitHub repository

### Ongoing (After Setup)
- âœ… Automated workflow publishes new versions on GitHub release
- âœ… Version numbers stay synchronized across pyproject.toml and git tags
- âœ… Each release documented in CHANGELOG.md
- âœ… Release process documented and reproducible

## Risk Mitigation

### Version Number Permanence
**Risk**: Once published to PyPI, version numbers cannot be reused.
**Mitigation**:
- Always test with Test PyPI first
- Validate version synchronization in PR reviews
- Consider version validation workflow (Phase 3.2)

### Token Security
**Risk**: Exposed PyPI tokens could allow unauthorized package updates.
**Mitigation**:
- Store tokens only in GitHub repository secrets (never commit)
- Use project-scoped tokens after first publish
- Rotate tokens if compromise suspected
- Enable 2FA on PyPI account

### Build Reproducibility
**Risk**: Build artifacts differ between local and CI environments.
**Mitigation**:
- CI already builds package artifacts in `.github/workflows/ci.yml`
- Use same Poetry version locally and in CI
- Lock file (`poetry.lock`) ensures consistent dependencies

### Breaking Changes
**Risk**: Users auto-update and experience breaking changes.
**Mitigation**:
- Follow semantic versioning strictly
- Document breaking changes clearly in CHANGELOG.md
- Consider deprecation warnings before removal

## Post-Publication Maintenance

### Version Management Strategy
Moving forward, maintain version synchronization:

1. **During development**: Keep version at current released version
2. **For release PR**: Bump version in pyproject.toml
3. **After merge**: Create matching git tag
4. **GitHub Release**: Triggers automated PyPI publish

### Suggested Workflow Improvements (Future)
- **Automated version bumping**: Script to update version across files
- **Version verification**: Pre-merge check that version hasn't been published
- **Automated changelog**: Generate from conventional commit messages
- **Release notes template**: Standardized GitHub release format

## Appendix: Poetry Publishing Commands Reference

### Configuration
```bash
# View current configuration
poetry config --list

# Add Test PyPI repository
poetry config repositories.testpypi https://test.pypi.org/legacy/

# Configure PyPI token (alternative to secrets)
poetry config pypi-token.pypi <token>
poetry config pypi-token.testpypi <token>
```

### Building
```bash
# Build package (creates wheel and tarball in dist/)
poetry build

# Build only wheel
poetry build -f wheel

# Build only sdist (source distribution)
poetry build -f sdist

# Clean previous builds
rm -rf dist/ build/ *.egg-info
```

### Publishing
```bash
# Publish to PyPI (prompts for credentials if not configured)
poetry publish

# Publish to Test PyPI
poetry publish -r testpypi

# Build and publish in one command
poetry publish --build

# Dry run (validate without publishing)
poetry publish --dry-run
```

### Validation
```bash
# Check pyproject.toml validity
poetry check

# Show package information
poetry show --tree

# Verify what will be included in package
poetry build -v
```

## Implementation Decisions

Based on user preferences, the following decisions have been made:

1. **First Release Version**: `v0.3.0`
   - Marks PyPI availability as a new minor version feature
   - Signals to users that pip installation is now officially supported
   - Clean version number for public package debut

2. **Dependency Reorganization**:
   - **pre-commit**: Move to dev dependencies (cleaner separation)
   - **ignition-api-stubs**: Remove from dependencies entirely (not used at runtime)
   - **Python version**: Update to support 3.13 (`>=3.10,<3.14`)
   - Reduces package installation footprint
   - Enables Python 3.13 support (requested by user)

3. **Testing Approach**: Test PyPI first, then manual production
   - Safest approach for first-time publishing
   - Validates full workflow before production
   - Allows iteration on any configuration issues

4. **Ownership**: Eric Knorr and Alex Spyksma (from current pyproject.toml)

5. **Repository**: `https://github.com/design-group/ignition-lint` (from current pyproject.toml)

## Implementation Recommendation

**Recommended approach for first-time PyPI publishing (aligned with user decisions):**

1. **Start with metadata updates** (Phase 1)
   - Update version to 0.3.0
   - Move pre-commit to dev dependencies
   - Add classifiers and keywords

2. **Set up PyPI credentials** (Phase 2)
   - Create Test PyPI account and token
   - Create production PyPI account and token
   - Configure GitHub secrets

3. **Test with Test PyPI** (Phase 5.1)
   - Build and publish to Test PyPI
   - Verify installation works
   - Iterate on any issues

4. **Manual production publish** (Phase 5.2)
   - Publish v0.3.0 to production PyPI
   - Create git tag v0.3.0
   - Create GitHub Release

5. **Create automated workflows** (Phase 3)
   - Now that package exists on PyPI
   - Can use project-scoped tokens
   - Future releases will be automated

6. **Write documentation** (Phase 4)
   - Document the established process in RELEASING.md
   - Update CLAUDE.md with release reference

7. **Verify and iterate** (Phase 6)
   - Test end-to-end pip installation
   - Verify pre-commit integration
   - Add PyPI badges to README

This approach follows the user's preference for careful manual testing before automation, minimizing risk while establishing the package on PyPI.
